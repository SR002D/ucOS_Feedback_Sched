# ucOS_Feedback_Sched

提出一种双优先级的RTOS反馈调度算法



具体代码请用Visual Studio打开项目文件：`ucOS_Feedback_Sched\ucos II-windows-20201023\Micrium_Win32_Kernel\Micrium_Win32_Kernel\Microsoft\Windows\Kernel\OS2\VS\OS2.sln`



# 完成度

- [X] 单个周期任务调度

- [X] 多个周期任务调度

- [X] 单个非周期任务调度

- [x] 多个非周期任务调度

- [x] 单个周期任务与单个非周期任务调度

- [x] 多个周期任务与单个非周期任务调度

- [x] 单个周期任务与多个非周期任务调度

- [x] 多个周期任务与多个非周期任务调度



# 二级优先级反馈

指定任务的时间片为`time_quanta`，若任务运行了整个时间片的时间还未运行完毕（被抢占、运行完成则跳过），则会降低该任务的优先级`pri`（优先级+2），并记录二级优先级`exr_info.pri`中，当二级优先级到达上线，则不会再降低优先级了。



优先级为0，1的为预留的硬实时任务优先级，不会采用降级策略

# 测试场景/数据

## 测试说明

旧算法在非周期任务使用的是FIFO，新算法使用的是EDF，本测试重点测试非周期任务占总体任务的占比，以此来展示新算法与旧算法的对比，主要从CPU利用率、上下文切换次数、任务失败率三个方面来展示。

## 测试背景

实验采用随机分配每个任务的20个时钟周期内的最坏运行时间，通过式子$$T_i=N*C_i/p$$来计算各个任务的周期，其中$$N$$为任务总数，

$$C_i$$为最坏运行时间，$$p$$为负载因子，对于非周期任务来说，$$T_i$$为非周期任务的截至日期而不是任务周期。

实验取$N$为20，$p$为1.0，观察时间区间为0~1000（时钟数）

（TODO：待更新低负载、高负载场景数据）

| 非周期任务占比 | 旧CPU利用率 | 新CPU利用率 | 旧上下文切换次数 | 新上下文切换次数 | 旧任务失败率 | 新任务失败率 |
| -------------- | ----------- | ----------- | ---------------- | ---------------- | ------------ | ------------ |
| 100%           | 20.1%       | 20.1%       | 46               | 48               | 10%          | 0%           |
| 75%            | 43.3%       | 43.3%       | 103              | 103              | 66.7%        | 60.8%        |
| 50%            | 63.6%       | 63.6%       | 126              | 126              | 75.4%        | 72.3%        |
| 25%            | 83.3%       | 83.3%       | 169              | 169              | 84.5%        | 84.5%        |
| 0%             | 94.2%       | 94.2%       | 197              | 197              | 84.5%        | 84.5%        |

